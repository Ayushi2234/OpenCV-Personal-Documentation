
# Indexing Routines

`ndarrays` can be indexed using the standard Python `x[obj]` syntax, where `x` is the array and `obj` is the selection. There are different kinds of indexing available depending on `obj`: basic indexing, advanced indexing, and field access.

Most of the following examples show the use of indexing when referencing data in an array. The examples work just as well when assigning to an array. See Assigning values to indexed arrays for specific examples and explanations on how assignments work.

Note that in Python, `x[(exp1, exp2, ..., expN)]` is equivalent to `x[exp1, exp2, ..., expN]`; the latter is just syntactic sugar for the former.

## Basic Indexing

### Single Element Indexing

Single element indexing works exactly like that for other standard Python sequences. It is 0-based, and accepts negative indices for indexing from the end of the array.

```python
x = np.arange(10)
x[2]
# 2
x[-2]
# 8
```

It is not necessary to separate each dimension’s index into its own set of square brackets.

```python
x.shape = (2, 5)  # now x is 2-dimensional
x[1, 3]
# 8
x[1, -1]
# 9
```

Note that if one indexes a multidimensional array with fewer indices than dimensions, one gets a subdimensional array. For example:

```python
x[0]
# array([0, 1, 2, 3, 4])
```

That is, each index specified selects the array corresponding to the rest of the dimensions selected. In the above example, choosing `0` means that the remaining dimension of length `5` is being left unspecified, and that what is returned is an array of that dimensionality and size. It must be noted that the returned array is a view, i.e., it is not a copy of the original, but points to the same values in memory as does the original array. In this case, the 1-D array at the first position (0) is returned. So using a single index on the returned array results in a single element being returned. That is:

```python
x[0][2]
# 2
```

So note that `x[0, 2] == x[0][2]` though the second case is more inefficient as a new temporary array is created after the first index that is subsequently indexed by `2`.

> **Note**: NumPy uses C-order indexing. That means that the last index usually represents the most rapidly changing memory location, unlike Fortran or IDL, where the first index represents the most rapidly changing location in memory. This difference represents a great potential for confusion.

### Slicing and Striding

Basic slicing extends Python’s basic concept of slicing to N dimensions. Basic slicing occurs when `obj` is a slice object (constructed by `start:stop:step` notation inside of brackets), an integer, or a tuple of slice objects and integers. `Ellipsis` and `newaxis` objects can be interspersed with these as well.

The simplest case of indexing with N integers returns an array scalar representing the corresponding item. As in Python, all indices are zero-based: for the `i-th` index, the valid range is 0 to `di - 1` where `di` is the `i-th` element of the shape of the array. Negative indices are interpreted as counting from the end of the array (i.e., if `i = -1`, it means `i = di - 1`).

All arrays generated by basic slicing are always views of the original array.

> **Note**: NumPy slicing creates a view instead of a copy as in the case of built-in Python sequences such as string, tuple, and list. Care must be taken when extracting a small portion from a large array that becomes useless after the extraction, because the small portion extracted contains a reference to the large original array whose memory will not be released until all arrays derived from it are garbage-collected. In such cases, an explicit `copy()` is recommended.

---

### what is the def of ellipsis in numpy
The ellipsis `(...)` in NumPy is a special `syntax for slicing` multidimensional arrays. It indicates selecting all remaining unspecified dimensions. When used in conjunction with other indices, it allows you to specify the dimensions explicitly and omit the others.

In the given example, n[1,...,1] is equivalent to n[1,:,:1], selecting the second row, all columns (i.e., full remaining dimensions), and the second column (index 1).

Here’s a breakdown of the behavior:

- `n[1]` selects the second row.
- `...` indicates selecting all remaining unspecified dimensions (in this     case, the columns and the third dimension).
- ,1 specifies the second column.

Using the `Ellipsis` object interchangeably, n[1, Ellipsis, 1] produces the same result.

The key benefit of ellipsis is that it simplifies the syntax for selecting specific parts of a multidimensional array while omitting others.

---
### what is the def of newaxis in numpy

In NumPy, `np.newaxis` is a special object used to add a new axis to an array. It is often referred to as the “newaxis” object. This object is used to increase the dimensionality of an array by one, allowing for the creation of arrays with shapes that would otherwise be incompatible.

When used in indexing, np.newaxis adds a new dimension to the array, effectively creating a new axis. For example, if you have an array x with shape `(n,)`, `x[:, np.newaxis]` would create a new array with shape `(n, 1)`, where the `original array x is now a column vector`.

In the context of the k-means algorithm, np.newaxis is used to reshape an array so that it can interact with another array that has a different shape. `This reshaping is necessary because the two arrays need to be broadcastable`, meaning they need to have compatible shapes for element-wise operations.

Here is an example of using np.newaxis to convert a vector to a column vector:

```py
import numpy as np

vec = np.array([1, 2, 3, 4, 5])
col_vec = vec[:, np.newaxis]
print(col_vec.shape)  # Output: (5, 1)
```

In this example, vec is a 1D array with shape (5,), and col_vec is a 2D array with shape (5, 1), where the original vector vec is now a column vector.

It’s worth noting that np.newaxis is equivalent to None when used in indexing, but it’s generally more readable and idiomatic to use np.newaxis explicitly.

Additionally, np.newaxis can be used in combination with other indexing operations, such as slicing and dstacking, to create more complex array reshaping scenarios.

In summary, np.newaxis is a powerful tool in NumPy that allows you to add a new axis to an array, making it a essential component in many array manipulation and reshaping operations.

---

The standard rules of sequence slicing apply to basic slicing on a per-dimension basis (including using a step index). Some useful concepts to remember include:

- The basic slice syntax is `i:j:k` where `i` is the starting index, `j` is the stopping index, and `k` is the step (`k` is optional). This selects the m elements (in the corresponding dimension) with index values `i, i + k, ..., i + (m - 1) k` where `m = q + (r!=0)` and `q` and `r` are the quotient and remainder obtained by dividing `j - i` by `k`: `j - i = q k + r`, so that `i + (m - 1) k < j`. For example:

```python
x = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
x[1:7:2]
# array([1, 3, 5])
```

- Negative `i` and `j` are interpreted as `n + i` and `n + j` where `n` is the number of elements in the corresponding dimension. Negative `k` makes stepping go towards smaller indices. From the above example:

```python
x[-2:10]
# array([8, 9])
x[-3:3:-1]
# array([7, 6, 5, 4])
```

- Assume `n` is the number of elements in the dimension being sliced. Then, if `i` is not given it defaults to `0` for `k > 0` and `n - 1` for `k < 0`. If `j` is not given it defaults to `n` for `k > 0` and `-n-1` for `k < 0`. If `k` is not given it defaults to `1`. Note that `::` is the same as `:` and means select all indices along this axis. From the above example:

```python
x[5:]
# array([5, 6, 7, 8, 9])
```

- If the number of objects in the selection tuple is less than `N`, then `:` is assumed for any subsequent dimensions. For example:

```python
x = np.array([[[1], [2], [3]], [[4], [5], [6]]])
x.shape
# (2, 3, 1)
x[1:2]
# array([[[4],
#         [5],
#         [6]]])
```

- An integer, `i`, returns the same values as `i:i+1` except the dimensionality of the returned object is reduced by 1. In particular, a selection tuple with the `p-th` element an integer (and all other entries `:`) returns the corresponding sub-array with dimension `N - 1`. If `N = 1` then the returned object is an array scalar. These objects are explained in Scalars.

- If the selection tuple has all entries `:` except the `p-th` entry which is a slice object `i:j:k`, then the returned array has dimension `N` formed by stacking, along the `p-th` axis, the sub-arrays returned by integer indexing of elements `i, i+k, …, i + (m - 1) k < j`.

- Basic slicing with more than one non-`:` entry in the slicing tuple, acts like repeated application of slicing using a single non-`:` entry, where the non-`:` entries are successively taken (with all other non-`:` entries replaced by `:`). Thus, `x[ind1, ..., ind2,:]` acts like `x[ind1][..., ind2, :]` under basic slicing.

> **Warning**: The above is not true for advanced indexing.

- You may use slicing to set values in the array, but (unlike lists) you can never grow the array. The size of the value to be set in `x[obj] = value` must be (broadcastable to) the same shape as `x[obj]`.

- A slicing tuple can always be constructed as `obj` and used in the `x[obj]` notation. Slice objects can be used in the construction in place of the `[start:stop:step]` notation. For example, `x[1:10:5, ::-1]` can also be implemented as `obj = (slice(1, 10, 5), slice(None, None, -1)); x[obj]`. This can be useful for constructing generic code that works on arrays of arbitrary dimensions. See Dealing with variable numbers of indices within programs for more information.

### Dimensional Indexing Tools

There are some tools to facilitate the easy matching of array shapes with expressions and in assignments.

- `Ellipsis` expands to the number of `:` objects needed for the selection tuple to index all dimensions. In most cases, this means that the length of the expanded selection tuple is `x.ndim`. There may only be a single ellipsis present. From the above example:

```python
x[..., 0]
# array([[1, 2, 3],
#        [4, 5, 6]])
```

This is equivalent to:

```python
x[:, :, 0]
# array([[1, 2, 3],
#        [4, 5, 6]])
```

- Each `

newaxis` object in the selection tuple serves to expand the dimensions of the resulting selection by one unit-length dimension. Thus, if `x` is an array with shape `(3, 4)`, `x[:, newaxis, :]` has shape `(3, 1, 4)`.

```python
x = np.array([1, 2, 3])
x[:, np.newaxis]
# array([[1],
#        [2],
#        [3]])
```

## Advanced Indexing

There are two types of advanced indexing: integer and Boolean.

### Integer Array Indexing

Advanced indexing is triggered when the selection object, `obj`, is a non-tuple sequence object, an ndarray (of data type integer or bool), or a tuple with at least one sequence object, ndarray, or `Ellipsis`. Advanced indexing always returns a copy of the data (contrast with basic slicing that returns a view).

Here's a link to difference between Basic Indexing and Advanced Indexing:[ Basic Indexing and Advanced Indexing](https://github.com/shyama7004/OpenCV-Personal-Documentation/blob/main/readme.md/Other%20Defs/Basic%20Indexing%20and%20Advanced%20Indexing.md) 

Advanced indexing can be combined with basic slicing. Advanced indexing is purely integer-based; if the selection object is not strictly an integer, it is treated as a sequence of integers and/or boolean values.

When the selection object is a sequence object or ndarray of integers, it defines a set of integer positions. These positions are then used to index into the array. For example:

```python
x = np.arange(10, 1, -1)
x
# array([10,  9,  8,  7,  6,  5,  4,  3,  2])
x[[0, 2, 4]]
# array([10,  8,  6])
```

If the selection object is a tuple of sequences of integers, the indices define a set of coordinates into the array. The result is a one-dimensional array with the specified elements:

```python
y = np.arange(35).reshape(5, 7)
y
# array([[ 0,  1,  2,  3,  4,  5,  6],
#        [ 7,  8,  9, 10, 11, 12, 13],
#        [14, 15, 16, 17, 18, 19, 20],
#        [21, 22, 23, 24, 25, 26, 27],
#        [28, 29, 30, 31, 32, 33, 34]])
y[1, 2]
# 9
y[1, 2] == y[1][2]
# True
```

If the selection object is a boolean array, it selects the positions where the boolean array is `True`. This is useful for selecting elements that satisfy a certain condition. For example:

```python
z = np.arange(12).reshape(3, 4)
z
# array([[ 0,  1,  2,  3],
#        [ 4,  5,  6,  7],
#        [ 8,  9, 10, 11]])
b = z > 5
b
# array([[False, False, False, False],
#        [False, False,  True,  True],
#        [ True,  True,  True,  True]])
z[b]
# array([ 6,  7,  8,  9, 10, 11])
```

```
